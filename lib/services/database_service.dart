// lib/services/database_service.dart

import 'package:isar/isar.dart';
import 'package:path_provider/path_provider.dart';
import 'package:raaz/song_model.dart';
import 'dart:io'; // For Directory

class DatabaseService {
  static final DatabaseService _instance = DatabaseService._internal();
  factory DatabaseService() => _instance;
  DatabaseService._internal();

  late Isar _isar;
  bool _isInitialized = false;

  // Initialize the Isar database
  Future<void> initialize() async {
    if (_isInitialized) return;
    try {
      final dir = await getApplicationDocumentsDirectory();
      _isar = await Isar.open(
        [SongSchema], // Pass the schema generated by build_runner
        directory: dir.path,
        name: 'raaz_music_db', // Optional name for the database instance
      );
      _isInitialized = true;
      print("[DatabaseService] Isar initialized successfully at ${dir.path}");
    } catch (e) {
      print("[DatabaseService] Error initializing Isar: $e");
      // Handle initialization error appropriately (e.g., show error message)
    }
  }

  // Ensure Isar is initialized before accessing
  Future<Isar> get _db async {
    if (!_isInitialized) {
      await initialize();
    }
    // Add a check in case initialization failed
    if (!_isInitialized) {
      throw Exception("[DatabaseService] Isar is not initialized.");
    }
    return _isar;
  }

  // Save a list of songs (insert or update based on filePath index)
  Future<void> saveSongs(List<Song> songs) async {
    final isar = await _db;
    try {
      await isar.writeTxn(() async {
        // Using putAll ensures unique constraint on filePath is handled
        await isar.songs.putAll(songs);
      });
      print("[DatabaseService] Saved/Updated ${songs.length} songs.");
    } catch (e) {
      print("[DatabaseService] Error saving songs: $e");
    }
  }

  // Load all songs from the database
  Future<List<Song>> loadSongs() async {
    final isar = await _db;
    try {
      final songs = await isar.songs.where().sortByTitle().findAll();
      print("[DatabaseService] Loaded ${songs.length} songs from DB.");
      return songs;
    } catch (e) {
      print("[DatabaseService] Error loading songs: $e");
      return []; // Return empty list on error
    }
  }

  // --- Add method to update lastPlayed timestamp ---
  Future<void> updateLastPlayed(Song song) async {
    final isar = await _db;
    try {
      await isar.writeTxn(() async {
        song.lastPlayed = DateTime.now(); // Set timestamp
        await isar.songs.put(song); // Save the updated song object
      });
      // print("[DatabaseService] Updated lastPlayed for: ${song.displayTitle}");
    } catch (e) {
      print(
          "[DatabaseService] Error updating lastPlayed for ${song.displayTitle}: $e");
    }
  }

  // --- Add method to get recent songs ---
  Future<List<Song>> getRecentSongs({int limit = 20}) async {
    final isar = await _db;
    try {
      // Find songs where lastPlayed is not null, sort descending, take limit
      final recentSongs = await isar.songs
          .where()
          .filter()
          .lastPlayedIsNotNull()
          .sortByLastPlayedDesc()
          .limit(limit)
          .findAll();
      print("[DatabaseService] Loaded ${recentSongs.length} recent songs.");
      return recentSongs;
    } catch (e) {
      print("[DatabaseService] Error loading recent songs: $e");
      return [];
    }
  }

  // Optional: Clear all songs (for debugging/reset)
  Future<void> clearAllSongs() async {
    final isar = await _db;
    try {
      await isar.writeTxn(() async {
        await isar.songs.clear();
      });
      print("[DatabaseService] Cleared all songs from DB.");
    } catch (e) {
      print("[DatabaseService] Error clearing songs: $e");
    }
  }

  // --- Add method to toggle favorite status ---
  Future<void> toggleFavorite(Song song) async {
    final isar = await _db;
    try {
      await isar.writeTxn(() async {
        song.isFavorite = !song.isFavorite; // Toggle the status
        await isar.songs.put(song); // Save the updated song object
      });
      print(
          "[DatabaseService] Toggled favorite for ${song.displayTitle} to ${song.isFavorite}");
    } catch (e) {
      print(
          "[DatabaseService] Error toggling favorite for ${song.displayTitle}: $e");
    }
  }

  // --- Add method to get favorite songs ---
  Future<List<Song>> getFavoriteSongs() async {
    final isar = await _db;
    try {
      // Find songs where isFavorite is true, sort by title
      final favoriteSongs = await isar.songs
          .where()
          .filter()
          .isFavoriteEqualTo(true)
          .sortByTitle() // Or sort as desired
          .findAll();
      print("[DatabaseService] Loaded ${favoriteSongs.length} favorite songs.");
      return favoriteSongs;
    } catch (e) {
      print("[DatabaseService] Error loading favorite songs: $e");
      return [];
    }
  }

  // --- Add method to delete a song (DB and File) ---
  Future<bool> deleteSong(Song song) async {
    final isar = await _db;
    try {
      // 1. Delete from Database
      bool dbDeleted = false;
      await isar.writeTxn(() async {
        dbDeleted = await isar.songs.delete(song.id);
      });

      if (!dbDeleted) {
        print(
            "[DatabaseService] Failed to delete song from DB: ${song.displayTitle}");
        return false; // Stop if DB deletion failed
      }
      print("[DatabaseService] Deleted song from DB: ${song.displayTitle}");

      // 2. Delete File from Storage
      final file = File(song.filePath);
      if (await file.exists()) {
        await file.delete();
        print("[DatabaseService] Deleted song file: ${song.filePath}");
        return true; // Success
      } else {
        print(
            "[DatabaseService] Song file not found, only removed from DB: ${song.filePath}");
        return true; // Still consider it a success as DB entry is gone
      }
    } catch (e) {
      print("[DatabaseService] Error deleting song ${song.displayTitle}: $e");
      return false; // Indicate failure
    }
  }

  // Optional: Close the database when done (e.g., in dispose or app termination)
  Future<void> close() async {
    if (_isInitialized) {
      await _isar.close();
      _isInitialized = false;
      print("[DatabaseService] Isar database closed.");
    }
  }
}
